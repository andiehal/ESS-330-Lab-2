<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Questions</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="Questions_files/libs/clipboard/clipboard.min.js"></script>
<script src="Questions_files/libs/quarto-html/quarto.js"></script>
<script src="Questions_files/libs/quarto-html/popper.min.js"></script>
<script src="Questions_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Questions_files/libs/quarto-html/anchor.min.js"></script>
<link href="Questions_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Questions_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Questions_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Questions_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Questions_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Questions</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="exercises--" class="level1">
<h1>Exercises -</h1>
<section id="filtering-rows" class="level3">
<h3 class="anchored" data-anchor-id="filtering-rows">1. Filtering rows</h3>
<blockquote class="blockquote">
<p><strong>Question 1:</strong> Read in the Minnesota tree growth dataset. Use glimpse to understand the structure and names of the dataset. Decribe the structure and what you see in the dataset?</p>
<ul>
<li>The columns are seperated into the tree ID numbers, the stand ID, the stand, year, species, age, inc, and read_ib. There is about 131,386 rows of data.</li>
</ul>
<p><strong>Question 2:</strong> How many records have been made in standID 1?</p>
<ul>
<li>There are 979 records of trees made with the standID “1”.</li>
</ul>
<p><strong>Question 3:</strong> How many records of the Abies balsamea and Pinus strobus species have been made?</p>
<ul>
<li>There are 13,033 Abies balsamea (“ABBA”) records, 4,188 Pinus strobus (“PIST”) records, and a total of 17,221 records.</li>
</ul>
<p><strong>Question 4:</strong> How many trees are older then 200 years old in the last year of the dataset?</p>
<ul>
<li>There are 7 trees that are over the age of 200 in the year 2007. Two of them are from the “PIRE” species, and five of them are from “FRNI.”</li>
</ul>
</blockquote>
</section>
<section id="slicing-rows" class="level3">
<h3 class="anchored" data-anchor-id="slicing-rows">2. Slicing Rows</h3>
<blockquote class="blockquote">
<p><strong>Question 5: What is the oldest tree in the dataset found using slice_max?</strong></p>
<ul>
<li>The oldest tree is the “PIRE” treeID 24, which was 269 years old in 2007.</li>
</ul>
</blockquote>
<blockquote class="blockquote">
<p><strong>Question 6: Find the oldest 5 trees recorded in 2001. Use the help docs to understand optional parameters</strong></p>
<ul>
<li>The oldest trees recorded were 263, 259, 212, 206, 206. Two of which were from “PIRE” and three of them from “FRNI.”</li>
</ul>
</blockquote>
<blockquote class="blockquote">
<p><strong>Question 7: Using slice_sample, how many trees are in a 30% sample of those recorded in 2002?</strong></p>
<ul>
<li>In a 30% sample size (39,415 records), 727 of those records were in 2002.</li>
</ul>
</blockquote>
</section>
<section id="arranging-rows" class="level3">
<h3 class="anchored" data-anchor-id="arranging-rows">3. Arranging Rows</h3>
<blockquote class="blockquote">
<p><strong>Question 8: Filter all trees in stand 5 in 2007. Sort this subset by <em>descending</em> radius at breast height (rad_ib) and use slice_head() to get the top three trees. Report the tree IDs</strong></p>
<ul>
<li>The three trees in standID 5 that had the largest radius at breast height were 128, 157, and 135.</li>
</ul>
</blockquote>
</section>
<section id="reducing-columns" class="level3">
<h3 class="anchored" data-anchor-id="reducing-columns">4. Reducing Columns</h3>
<blockquote class="blockquote">
<p><strong>Question 9: Reduce your full <code>data.frame</code> to [treeID, stand, year, and radius at breast height]. Filter to only those in stand 3 with records from 2007, and use slice_min to pull the smallest three trees meaured that year.</strong></p>
<ul>
<li>The smallest trees from this selection measured in 2007 were 50, 56, and 36.</li>
</ul>
</blockquote>
<blockquote class="blockquote">
<p><strong>Question 10: Use select to <em>remove</em> the stand column. Use glimspe to show the dataset.</strong></p>
<ul>
<li>Done.</li>
</ul>
</blockquote>
<blockquote class="blockquote">
<p><strong>Question 11: Look at the help document for dplyr::select and examine the “Overview of selection features”. Identify an option (there are multiple) that would help select all columns with the string “ID” in the name. Using glimpse to view the remaining dataset</strong></p>
<ul>
<li>Done, used “contains(”ID”).”</li>
</ul>
<p><strong>Question 12: Find a selection pattern that captures all columns with either ‘ID’ or ‘stand’ in the name. Use glimpse to verify the selection.</strong></p>
<ul>
<li>The columns that were selected was “treeID”, “stand”, and “standID.”</li>
</ul>
</blockquote>
</section>
<section id="renaming-columns" class="level3">
<h3 class="anchored" data-anchor-id="renaming-columns">5. Renaming Columns</h3>
<blockquote class="blockquote">
<p><strong>Question 13: Looking back at the data dictionary, rename rad_inc and inc to include <code>_[unit]</code> in the name. Unlike earlier options, be sure that this renaming is permanent, and stays with your data.frame (e.g.&nbsp;<code>&lt;-</code>). Use glimpse to view your new data.frame.</strong></p>
<ul>
<li>Done!</li>
</ul>
</blockquote>
</section>
<section id="creating-new-columns" class="level3">
<h3 class="anchored" data-anchor-id="creating-new-columns">6. Creating New Columns</h3>
<blockquote class="blockquote">
<p><strong>Question 14: A key measurement in forestry in “basal area column”. The metric is computed with the formula:<br>
BA(m2) = 0.00007854⋅DBH^2<br>
Where DBH is the diameter at breast height (cm). Use mutate to compute DBH in centimeters, and BA in m2 (HINT: Make sure rad_ib is in cm prior to computing the diameter!). What is the mean BA_m2 of the the species <code>POTR</code> in 2007?</strong></p>
<ul>
<li>The mean of the basal area of POTR in 2007 is 0.009241546 m^2.</li>
</ul>
</blockquote>
</section>
<section id="case_when-if_else" class="level3">
<h3 class="anchored" data-anchor-id="case_when-if_else">7. case_when / if_else</h3>
<blockquote class="blockquote">
<p><strong>Question 15: Lets say for the sake of our study, trees are not established until they are 5 years of age. Use <code>if_else</code> to add a boolean column to our dataset called <code>established</code> that is TRUE if the age is greater then 5 and FALSE if less then or equal to five. Once added, use count (see ?count) to determine how many records are from estabilshed trees?</strong></p>
<ul>
<li>There are 122,503 established trees and 8,883 young trees.</li>
</ul>
<p><strong>Question 16: Use <code>mutate</code> and <code>case_when</code> to add a new column to you data.frame that classifies each tree into the proper DBH_class. Once done, limit your dataset to the year 2007 and report the number of each class with count.</strong></p>
<ul>
<li>There are 473 “poles”, 1817 “saplings”, and 1 “sawlog.”</li>
</ul>
</blockquote>
</section>
<section id="summarizing" class="level3">
<h3 class="anchored" data-anchor-id="summarizing">8. Summarizing</h3>
<blockquote class="blockquote">
<p><strong>Question 17: Compute the mean DBH (in cm) and standard deviation of DBH (in cm) for all trees in 2007. Explain the values you found and their statistical meaning.</strong></p>
<ul>
<li><p>The mean of DBH for all trees in 2007 is 8.046755, which measures the sum of all the DBH records divided by the number of observations to find the “average” diameter at breast height.</p></li>
<li><p>The standard deviation of DBH for all trees in 2007 is 3.069321, this finds the amount of variation from the mean value.</p></li>
</ul>
</blockquote>
</section>
<section id="grouped-data" class="level3">
<h3 class="anchored" data-anchor-id="grouped-data">9. Grouped Data</h3>
<blockquote class="blockquote">
<p><strong>Question 18: Compute the <em>per species</em> mean tree age using only those ages recorded in 2003. Identify the three species with the oldest mean age.</strong></p>
<ul>
<li>The tree species with the oldest mean ages are THOC (126.63830), FRNI (83.08333), and PIST (73.28571).</li>
</ul>
</blockquote>
</section>
<section id="counting" class="level3">
<h3 class="anchored" data-anchor-id="counting">10. Counting</h3>
<blockquote class="blockquote">
<p><strong>Question 19: In a single summarize call, find the number of unique years with records in the data set along with the first and last year recorded?</strong></p>
<ul>
<li>The largest amount of unique years was 111 different years. The 1st year recorded was 1897 and the latest year was 2007.</li>
</ul>
<p><strong>Question 20: Determine the stands with the largest number of unique years recorded. Report all stands with largest (or tied with the largest) temporal record.</strong></p>
<ul>
<li>The stands with the tie for the largest amount of unique years recorded were A1, D1, D2, D3, and F1 with 111 unique years.</li>
</ul>
</blockquote>
</section>
<section id="final-question" class="level3">
<h3 class="anchored" data-anchor-id="final-question">Final Question</h3>
<blockquote class="blockquote">
<p><strong>Use a combination of dplyr verbs to compute these values and report the 3 species with the fastest growth, and the 3 species with the slowest growth. (** You will need to use either <code>lag()</code> or <code>diff()</code> in your compuation. You can learn more about each in the Help pages)</strong></p>
<p><strong>Lastly, find and include an image of the fastest growing species. Add the image to your images directory.</strong></p>
<ul>
<li><p>The fastest growing trees species were PIRE (0.0221793750), PIST (0.0133043457), and POTR (0.0120377590).</p></li>
<li><p>The slowest growing trees species were ABBA (-0.0197856392), PIGL (-0.0107553007), and ACRU (-0.0053966451).</p></li>
</ul>
</blockquote>
<hr>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Red%20Pine%20Photo%20-%20Gynosperm%20Database.jpg" class="img-fluid figure-img"></p>
<figcaption>This image depicts the fastest growing tree species, the Pinus resinosa (aka the ‘Red Pine’) This identification photo comes from the Gymnosperm Datadase and is titled “Trees, foliage and cones.” This drawing is by Matt Strieby, 2018.</figcaption>
</figure>
</div>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>